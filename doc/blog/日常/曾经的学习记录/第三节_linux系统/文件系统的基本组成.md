## 文件系统详解



### 1、文件系统的基本组成

​	文件系统就是操作系统中负责管理持久数据的子系统（持久化的将文件保存在硬盘上）

​	文件系统的基本数据单位是文件，目的是对磁盘上的文件进行管理

​	Linux，一切皆文件

​	Linux数据系统会为每个文件分配两个数据结构：**索引节点**(index node)和**目录项**(directory entry)，记录文件元信息和目录层次结构

​	**索引节点**：记录文件的元信息，如访问权限、大小、数据在磁盘的位置等等，储存在硬盘中

​	**目录项**：记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，形成目录结构，与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘而是存在于内存

### 2、虚拟文件系统

​	文件系统的种类繁多，而操作系统希望对用户提供一个统一的接口，于是在用户层和文件系统层中引入了中间层，被称为虚拟文件系统



### 3、文件存储方式

###### 3.1、连续空间存放：

​	连续的物理空间存储，易产生磁盘碎片

###### 3.2、非连续空间存放：

​	**3.2.1、链表方式**：

​		**隐式链表**：实现的方式是文件头要包含磁盘块“第一块”和“最后一块”的位置，并且每个数据块留出一个指针空间，用来存放下一个数据块的位置。稳定性较差，一般发生错误导致指针损坏，会导致文件数据的丢失

​		**显式链接**：相当于在隐式的基础上取出所有的指针，放在内存的一个表上。链接文件各个数据块的指针，显式的存放在内存的一张表中，每个表项中存放链接指针，指向下一个数据块号。（表在内存，不适用与大磁盘）

​		链表的方式解决了连续分配的磁盘碎片和文件动态拓展问题，但是不能有效支持直接访问（FAT除外）

​	**3.2.2、索引方式**：

​		索引解决了直接访问的问题。索引的现实是为每个文件创建一个索引数据块，里面存放的是指向文件数据块的指针列表。

​		索引的缺陷在于储存索引带来的额外开销

​	**3.2.3、链式索引块**：

​		链表加索引的组合，实现方式是在索引数据块留出一个存放下一个索引数据块的指针。会出现某个索引数据块坏了导致文件受损。

​	**3.2.4、多级索引块**：

​		通过一个索引块来存储多个索引数据块（俄罗斯套娃）。



早期**Unix存储**结合了以上的优点：

一个索引文件头（Inode）——————>10个数据块

​											——————>一级索引数据块——————>n个数据块

​											——————>二级索引数据块——————>n^2个数据块

​											——————>三级索引数据块——————>n^3个数据块

​	如果存放文件的数据块超过10块，采用直接查找的方式；

​	超过10块，采用一级间接索引；

​	以上不够存放大文件，采用二级索引；

​	以上不够存放大文件，采用三级索引。

​	文件头包含13个指针，10个指向数据块，各1个一、二、三级索引的指针指向。

​	

​	此方案用在了Linux Ext2/3文件系统里，解决了大文件的存储，但是对于大文件的访问需要大量的查询，访问效率低。



### 4、空闲空间管理

###### 4.1、空闲表法：

​	为所有的空闲空间建立一张表，包含空闲区的第一个块号和该空闲区的个数（连续分配）

###### 4.2、空闲链表法

​	所有的空闲块以链表的方式来指向，特点是简单

​	缺点：指针会消耗一定存储空间，不能随机访问，效率低

​	空闲表和空闲链表都不适合大文件系统，否则会使表太大

###### 4.3、位图法

​	利用二进制的一位来表示磁盘中一个盘块的使用情况

​	（Linux就采用此法管理空闲空间，还用来进行Inode空闲块的管理，因为Inode也是存在磁盘的）



### 5、文件系统的结构

​	数据库的位图是放在磁盘块里的，假设是放在一个块里，一个块4 k，每位表示一个数据块，共可以表示4 * 1024 * 8 = 2^15个空闲块，由于一个数据块是4 k大小，那么最大可以表示 2^15 * 4 * 1024 = 2^27 个byte，也就是128 M。

​	也就是说按照上面的结构，采用 [一个块的位图 + 一系列的块] ，外加 [一个iNode的位图 + 一系列iNode的结构] 所表示的内容最大128 M太少了。

​	上述结构在Linux中被称为一个**块组**， 那么有n多的块组，就能表示n大的文件

​	Linux Ext2 整个文件系统由1 k的引导块加n个块组组成，块组包含：

​		超级块1块

​		块组描述符多块

​		数据位图一块

​		iNode位图一块

​		iNode列表多块

​		数据块多块

​	其中，**超级块**与**块组描述符**是全局信息，非常重要

​	Ext2的后续系统中采用了稀疏技术（并不是每一块都有**超级块**与**块组描述符**）。



### 6、目录的存储

​	目录文件的块里保存着目录里面一项项文件信息。

​	Linux的Ext文件系统就是采用了哈希表，来保存目录的内容。

​	目录查询通过在磁盘反复搜索所完成，i/o开销比较大，所以可以先缓存在内存里面。



### 7、软链接和硬链接

​	硬链接：多个目录项的索引节点指向一个文件系统，而 iNode 是不可跨文件系统的，每个文件系统都有自己的iNode数据结构和列表，所以硬链接是不可跨文件系统的。只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。

​	软链接：相当于重新创建一个文件，这个文件有独立的inode，但是文件内容是另外一个文件的路径，所以访问软链接的时候，实际相当于访问到另一个文件，所以软链接是可跨越文件系统的。



总结一下：

- 硬链接： 与普通文件没什么不同，`inode` 都指向同一个文件在硬盘中的区块
- 软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。



### 8、文件i/o

​	分类：

​		缓冲与非缓冲i/o：是否通过标准库的缓存访问文件（缓冲：标准库内部的缓冲）。

​		直接与非直接i/o：（是否利用操作系统的缓存，内核空间缓存，也叫页缓存）

​			直接i/o：不会发生内核缓存和用户数据之间的复制，而是直接经过文件系统访问磁盘。

​			非直接i/o：读操作时，数据从内核缓存拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写到磁盘

​		阻塞与非阻塞i/o VS 同步与异步i/o：

​			阻塞等待的是“内核数据准备好”和“数据从内核态拷贝到用户态”这两个过程。

​			非阻塞，read在为准备好时立即返回，后又轮询。以为太傻了，改进了有了多路复用（都是同步的）。

​			异步不需等待，可以直接去做其他的，系统会自己完成调用写到程序空间
