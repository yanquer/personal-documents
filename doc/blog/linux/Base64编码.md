### Base64编码

编码表

| **索引** | **对应字符** | **索引** | **对应字符** | **索引** | **对应字符** | **索引** | **对应字符** |
| ------ | -------- | ------ | -------- | ------ | -------- | ------ | -------- |
| 0      | **A**    | 17     | **R**    | 34     | **i**    | 51     | **z**    |
| 1      | **B**    | 18     | **S**    | 35     | **j**    | 52     | **0**    |
| 2      | **C**    | 19     | **T**    | 36     | **k**    | 53     | **1**    |
| 3      | **D**    | 20     | **U**    | 37     | **l**    | 54     | **2**    |
| 4      | **E**    | 21     | **V**    | 38     | **m**    | 55     | **3**    |
| 5      | **F**    | 22     | **W**    | 39     | **n**    | 56     | **4**    |
| 6      | **G**    | 23     | **X**    | 40     | **o**    | 57     | **5**    |
| 7      | **H**    | 24     | **Y**    | 41     | **p**    | 58     | **6**    |
| 8      | **I**    | 25     | **Z**    | 42     | **q**    | 59     | **7**    |
| 9      | **J**    | 26     | **a**    | 43     | **r**    | 60     | **8**    |
| 10     | **K**    | 27     | **b**    | 44     | **s**    | 61     | **9**    |
| 11     | **L**    | 28     | **c**    | 45     | **t**    | 62     | **+**    |
| 12     | **M**    | 29     | **d**    | 46     | **u**    | 63     | **/**    |
| 13     | **N**    | 30     | **e**    | 47     | **v**    |        |          |
| 14     | **O**    | 31     | **f**    | 48     | **w**    |        |          |
| 15     | **P**    | 32     | **g**    | 49     | **x**    |        |          |
| 16     | **Q**    | 33     | **h**    | 50     | **y**    |        |          |

例子：

转换前 10101101,10111010,01110110

转换后 00101011, 00011011 ,00101001 ,00110110

十进制 43 27 41 54

对应码表中的值 r b p 2

所以上面的24位编码，编码后的Base64值为 rbp2

解码同理，把 rbq2 的二进制位连接上再重组得到三个8位值，得出原码。

（解码只是编码的逆过程，有关MIME的RFC还有很多，如果需要详细情况请自行查找。）

过程：

第一个字节，根据源字节的第一个字节处理。

规则：源第一字节右移两位，去掉低2位，高2位补零。

既：00 + 高6位

第二个字节，根据源字节的第一个字节和第二个字节联合处理。

规则如下，第一个字节高6位去掉然后左移四位，第二个字节右移四位

即：源第一字节低2位 + 源第2字节高4位

第三个字节，根据源字节的第二个字节和第三个字节联合处理，

规则第二个字节去掉高4位并左移两位（得高6位），第三个字节右移6位并去掉高6位（得低2位），相加即可

第四个字节，规则，源第三字节去掉高2位即可

//用更接近于编程的思维来说，编码的过程是这样的：

//第一个字符通过右移2位获得第一个目标字符的Base64表位置，根据这个数值取到表上相应的字符，就是第一//个目标字符。

//然后将第一个字符与0x03(00000011)进行与(&)操作并左移4位,接着第二个字符右移4位与前者相或(|)，即获得第二个目标字符。

//再将第二个字符与0x0f(00001111)进行与(&)操作并左移2位,接着第三个字符右移6位与前者相或(|)，获得第三个目标字符。

//最后将第三个字符与0x3f(00111111)进行与(&)操作即获得第四个目标字符。

//在以上的每一个步骤之后，再把结果与 0x3F 进行 AND [位操作](https://baike.baidu.com/item/位操作) ，就可以得到编码后的字符了。

原文的字节数量应该是3的倍数，如果这个条件不能满足的话，具体的解决办法是这样的：原文剩余的字节根据编码规则继续单独转(1变2，2变3；不够的位数用0补全)，再用=号补满4个字节。这就是为什么有些Base64编码会以一个或两个等号结束的原因，但等号最多只有两个。因为一个原字节至少会变成两个目标字节，所以余数任何情况下都只可能是0，1，2这三个数中的一个。如果余数是0的话，就表示原文字节数正好是3的倍数（最理想的情况）。如果是1的话，转成2个Base64编码字符，为了让Base64编码是4的倍数，就要补2个等号；同理，如果是2的话，就要补1个等号。

**原理：三个字节的八个字符 = 四个字节的六个字符 （3\*8=4\*6）**

流程：

1、将字符转为ascii

2、将ascii转为二进制

3、原有的三字节在这里以源一、二、三代表

- 转换后的第一个字节：00 + 源一的高六位字符
- 转换后的第二个字节：00 + 源一的低二位字符 + 源二的高四位字符
- 转换后的第三个字节：00 + 源二的低四位字符 + 源三的高二位字符
- 转换后的第四个字节：00 + 源三的低六位字符

4、转换的二进制转换为十进制，根据编码表编码

注意：转换后的编码默认每76个字符换行，若不需换行，shell中 base64 -w 0即可

```sh
base64                #编码
base64 -w num        #指定以多少个字符换行，为0则并不换行
base64 -d            #解码
```


